Существует три основных парадигмы: 
    Структурное, 
    Объектно-ориентированное, 
    Функциональное. 


1) Структурное программирование 
    Структурное программирование — это разработка программ с помощью представления их в виде иерархической структуры блоков.

    Эта парадигма разработана в 70-х годах XX века Э. Дейкстрой и Н. Виртом.

    Любая программа представляет собой структуру, построенную из трёх типов базовых конструкций:

    Последовательное исполнение — однократное выполнение операций в том порядке, в котором они записаны в тексте программы.

    Ветвление — однократное выполнение одной из двух или более операций в зависимости от выполнения некоторого заданного условия.

    Цикл — многократное исполнение одной и той же операции до тех пор, пока выполняется некоторое заданное условие (условие продолжения цикла).

    Разработка программы ведётся пошагово, методом «сверху вниз».

    Структурное программирование широко используется в крупномасштабных проектах.

2) Объектно-ориентированное программирование

    Объектно-ориентированное программирование (ООП) — это подход разработки, при котором программу создают из объектов, взаимодействующих друг с другом.

    Основные задачи ООП:

        упорядочивать информацию и избегать путаницы;

        повышать читабельность;

        ускорять понимание логики программы;

        оперативно масштабировать код;

        вносить изменения в отдельные участки кода, не ломая общей логики;

        повышать безопасность кода и сокращать его дублирование.

    Ключевые принципы ООП:

        инкапсуляция;

        наследование;

        полиморфизм;

        абстракция.


    Инкапсуляция. Скрытие деталей реализации объекта и предоставление только интерфейса для взаимодействия с ним. 
    Это позволяет изолировать изменения в одной части программы от других частей, что делает код более надёжным и 
    устойчивым к изменениям.

    Наследование. Создание новых классов на основе существующих. Это способствует повторному использованию кода и 
    созданию иерархий классов.

    Полиморфизм. Способность объектов разных классов обладать общим интерфейсом. Это позволяет обрабатывать объекты 
    разных типов с помощью общих методов и функций.

    Абстракция. Выделение общих характеристик объектов и создание абстрактных классов или интерфейсов для их представления. 
    Абстракция помогает упростить модель системы, делая её более понятной и управляемой.

3) Функциональное программирование – это раздел дискретной математики и парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном программировании).
Противопоставляется парадигме императивного программирования, которая описывает процесс вычислений как последовательность изменения состояний.
Функциональное программирование не предполагает изменяемость данных (в отличие от императивного, где одной из базовых концепций является переменная).
Принципы (концепции):

Функции высших порядков
Чистые функции
Рекурсия (в функционалке нет такого понятия как цикл, всё реализуется через рекурсию(функция вызывает сама себя), но не всегда)
Лямбда-исчисление являются основой для функционального программирования

02. Особенности функционального программирования
Функциональная программа представляет собой набор определений функций.

Функции определяются через другие функции или рекурсивно через самих себя.

При выполнении программы функции получают параметры, вычисляют и возвращают результат, при необходимости вычисляя значения других функций.

На функциональном языке программист не должен описывать порядок вычислений.

Нужно просто описать желаемый результат как систему функций.

Вызов функций - единственный вид действий, выполняемых в функциональном программировании.

Основной особенностью функционального программирования, определяющей как преимущества, так и недостатки данной парадигмы, является то, что в ней реализуется модель вычислений без состояний.
Если императивная программа на любом этапе исполнения имеет состояние, то есть совокупность значений всех переменных, и производит побочные эффекты, то чисто функциональная программа ни целиком, ни частями состояния не имеет и побочных эффектов не производит.
То, что в императивных языках делается путём присваивания значений переменным, в функциональных достигается путём передачи выражений в параметры функций.
Непосредственным следствием становится то, что чисто функциональная программа не может изменять уже имеющиеся у неё данные, а может лишь порождать новые путём копирования и/или расширения старых.
Следствием того же является отказ от циклов в пользу рекурсии.
03. Функция в парадигме функционального программирования
Функция — это описание процесса, связывающего вход с каким-то выводом. Так же как в любом другом языке программирования.
Функция — это базовый элемент функционального программирования.
Функции используются почти для всего, даже для простейших расчётов.
Даже переменные заменяются функциями.
04. Математическая функция и функциональное программирование
Математические функции выражают связь между исходными данными и итоговым продуктом некоторого процесса.

Процесс вычисления также имеет вход и выход, поэтому функция - вполне подходящее и адекватное средство описания вычислений.

Именно этот простой принцип положен в основу функциональной парадигмы и функционального стиля программирования.

Множество допустимых входных значений функции называются domain (область определения).
Множество возможных результатов функции (область значений) называется range (технически, изображение codomain-а).
Функцией называют отображение (в оригинале map) из domain-а в range. (Т.е. из области определения в область значений.)
В математическом понимании функция является правилом сопоставления каждому элементу области определения функции в точности одного элемента из области значений

image

05. История и основные вехи функционального программирования
Теория, положенная в основу функционального подхода, родилась в 20-х — 30-х годах.
В числе разработчиков математических основ функционального программирования можно назвать Моисея Шейнфинкеля и Хаскелла Карри, разработавших комбинаторную логику, и Алонзо Чёрча, создателя лямбда-исчисления.
В конце 1950-х годов Джон Маккарти разработал язык Лисп, который стал первым почти функциональным языком программирования и многие годы оставался единственным таковым.
В конце 70-х — начале 80-х годов XX века интенсивно разрабатываются модели типизации, подходящие для функциональных языков.
Большинство этих моделей включали в себя поддержку таких мощных механизмов как абстракция данных и полиморфизм.
Появляется множество типизированных функциональных языков: ML, Scheme, Hope, Miranda, Clean и многие другие. Вдобавок постоянно увеличивается число диалектов.
В результате вышло так, что практически каждая группа, занимающаяся функциональным программированием, использовала собственный язык. Это препятствовало дальнейшему распространению этих языков и порождало многие более мелкие проблемы.
Чтобы исправить положение, объединённая группа ведущих исследователей в области функционального программирования решила воссоздать достоинства различных языков в новом универсальном функциональном языке.
Первая реализация этого языка, названного Haskell в честь Хаскелла Карри, была создана в начале 90-х годов. Ныне действителен стандарт Haskell-98.
Большинство функциональных языков программирования реализуются как интерпретируемые, следуя традициям Лиспа
06. Свойства и характеристики функционального программирования
Все функции — чистые
Все функции — первого класса и высшего порядка
Переменные неизменяемы
Относительная прозрачность функций
Функциональное программирование основано на лямбда-исчислении
07. Чистые функции. Примеры.
Все функции являются чистыми, если они удовлетворяют двум условиям:

Функция, вызываемая от одних и тех же аргументов, всегда возвращает одинаковое значение.
Во время выполнения функции не возникают побочные эффекты.
Вызывая функцию sum(2, 3), вы ожидаете, что результат всегда будет равен 5.
Как только вы вызываете функцию rand(), или обращаетесь к переменной, не определённой в функции, чистота функции нарушается, а это в функциональном программировании недопустимо.
// самый простой пример - увеличение числа на 1, 
// не изменяется при передаче одинаковых значений
// не создаёт побочные эффекты
var add1 = y => y + 1;
08. Побочные эффекты. Проблемы и особенности.
Побочный эффект — это изменение чего-то отличного от функции, которая исполняется в текущий момент.

Изменение переменной вне функции
Вывод в консоль
Вызов исключения
Чтение данных из файла
— всё это примеры побочных эффектов, которые лишают функцию чистоты.

Если вы уверены, что вызов функции не изменит ничего «снаружи», то вы можете использовать эту функцию в любом сценарии. Это открывает дорогу конкурентному программированию и многопоточным приложениям.
Сила чистых функций:

Их легко распараллелить. Скажем, можно бы взять целые числа в диапазоне от 1 до 1000 и раздать их 1000 различных процессоров,

после чего поручить каждому CPU выполнить add1 над соответствующим числом,

одновременно будучи уверенным, что нет необходимости в каком-либо взаимодействии между ними.

Не потребуется ни блокировок, ни мьютексов, ни семафоров, ни т.п.

Можно использовать функции лениво,

вычисляя их тогда, когда это необходимо для логики программы.

Можно быть уверенным, что ответ будет точно таким же, независимо от того, проводятся вычисления сейчас или позже.

Можно лишь один раз провести вычисления функции

для конкретного входа, после чего закешировать результат,

потому что известно, что данные входные значения будут давать такой же выход.

Их можно вычислять в любом порядке

если есть множество чистых функций.

Опять же, это не может повлиять на финальный результат.

09. Функции первого и высшего порядка. Проблемы и особенности.
Для того, чтобы функция была первоклассной, у неё должна быть возможность быть объявленной в виде переменной.
Это позволяет управлять функцией как обычным типом данных и в то же время исполнять её.

Функции высшего порядка определяются как функции, принимающие другую функцию как аргумент или возвращающие функцию.
Типичными примерами таких функций являются map и filter.

10. Переменные в функциональном программировании.
Переменная в лямбда-исчислении — это то же самое что переменная в любом языке программирования, контейнер для какого-то значения.
Область видимости переменной определяется ближайшей функцией или скобками.
Переменные в лямбда-исчислении могут быть свободными или связанными.
Связанная переменная — это переменная, которая используется в области видимости, после того как она была объявлена в аргументах ближайшей функции, в иных случаях она свободна.
11. Состояние функций в функциональном программировании.
Функция — это описание процесса, связывающего вход с каким-то выводом.

Так же как в любом другом языке программирования.

Сверх этого, все функции в лямбда-исчислении:

анонимные, то есть не могут иметь имен
могут принимать только одну переменную, то есть их арность всегда равна 1
являются “объектами первого класса”, то есть могут быть входными и выходными значениями в функциях
12. Лямбда исчисление
Лямбда-исчисление — это формальная система в математической логике для описания вычислений с помощью абстракции и аппликации функций, использующая связывание переменных и подстановку
Любой функциональный язык программирования — это надстройка над лямбда-исчислением
Основные понятия в лямбда-исчислении это: переменные, лямбда термы, аппликация и абстракция.
Абстракция — это просто объявление функции. Оно обозначается символом λ. После этого символа Вы пишете входные переменные функции, потом точку и вывод функции, в котором Вы описываете, что ожидаете получить (то есть, это одновременно и тело функции).

Переменная в лямбда-исчислении — это то же самое что переменная в любом языке программирования, контейнер для какого-то значения. Область видимости переменной определяется ближайшей функцией или скобками. Переменные в лямбда-исчислении могут быть свободными или связанными. Связанная переменная — это переменная, которая используется в области видимости, после того как она была объявлена в аргументах ближайшей функции, в иных случаях она свободна.

Здесь “x” связана, а “y” свободна:

λx.xy

Лямбда терм — это базовая сущность в лямбда-исчислении. По сути, он может быть переменной или какой-то функцией. Любая переменная, а также любая абстракция и аппликация являются корректными лямбда термами, всё остальное не считается. Лямбда терму может быть присвоено имя для простоты повторного использования.

К примеру, терм идентичности (вход такой же как вывод) определяется вот так: I := λx.x
Функция — это описание процесса, связывающего вход с каким-то выводом. Так же как в любом другом языке программирования. Сверх этого, все функции в лямбда-исчислении:

анонимные, то есть не могут иметь имен
могут принимать только одну переменную, то есть их арность всегда равна 1 являются “объектами первого класса”, то есть могут быть входными и выходными значениями в функциях
Аппликация — это процесс применения лямбда терма к другому лямбда терму (переменной или функции). Для того чтобы написать аппликацию в лямбда-исчислении нужно просто поставить пробел между термами: • x y

Каррирование

Математические функции всегда имеют один вход и один выход

Как можно сделать что-либо полезное без функций с двумя (или более) параметрами?
Ответ довольно прост: функция с несколькими параметрами переписывается как серия новых функций, каждая из которых принимает только один параметр. Эту операцию компилятор выполняет автоматически, и называется она "каррирование" (currying), в честь Хаскела Карри, математика, который существенно повлиял на разработку функционального программирования.
При вызове каррированной функции с передачей ей одного аргумента, она возвращает новую функцию, которая ожидает поступления следующего аргумента.
13. Лямбда выражение в C#
Лямбда выражения - это анонимная функция, содержащая выражения и операторы

Синтаксис:

Используется лямбда-оператор => (goes to)

Параметры передаются в круглых скобках ()

Тело «функции» содержит выражение или утверждение и может быть заключено в фигурные скобки {}

Неявное лямбда-выражение

msg => Console.WriteLine(msg);
Явное лямбда-выражение

  (string msg) => { Console.WriteLine(msg); }
Без параметров

() => { Console.WriteLine("hi"); }
() => MyMethod();
С параметрами

(int x, int y) => { return x + y; }
14. Делегаты – особенности и отличие от функций.
Делегат – типизированная ссылка на метод с определенным списком параметров и типом возвращаемого значения
Используется для передачи методов в качестве аргументов другим методам
Может использоваться для определения «callback» методов
15. Обобщенный делегат Func в C#
Инициализация функции
Func<int, string> func = n => n.ToString();
Тип ввода и результата может быть разным
Тип ввода и результата должен быть объявленным типом
Обобщенный делегат использует типы параметров для определения количества и типов входных и выходных параметров
16. Обобщенный делегат Action в C#
Инкапсулирует метод, который не имеет параметров и не возвращает значений.

Примечание:

Action не имеет параметров
Action<T> может иметь параметры
По простому – ссылка на void метод:

Обычная функция

private void Print(string message)
{ 
    Console.WriteLine(message); 
}
Такая же функция в виде делегата Action

Action<string> print = message =>
    Console.WriteLine(message);
17. Делегат как параметр функции
Мы можем передавать Func<T> (и Action) методам:

private int Operation(int number, Func<int, int> operation)
{
    return operation(number);
}
И использовать вот так

int a = 5;
int b = Operation(a, number => number * 5); // 25
int c = Operation(a, number => number – 3); // 2
int d = Operation(b, number => number % 2); // 1
18. Лямбда выражение в Java
Лямбда выражение - это анонимная функция, содержащая выражения и операторы

Синтаксис
(parameters) -> {body}
Используйте лямбда-оператор ->
Параметры переданы в круглых скобках ()
Тело «функции» содержит выражение или утверждение и может быть заключено в фигурные скобки {}
Неявное лямбда-выражение
(msg) -> { System.out.println(msg); }
Явное лямбда-выражение
String msg -> System.out.println(msg);
Без параметров
() -> { System.out.println("Hello!"); }
С параметрами
(int x, int y) -> { return x + y; }
19. Функциональный интерфейс Function в Java
Мы можем создавать функции аналогичные математическим функциям:

Function<Integer, Integer> func = x -> x * x;
В Java Function<T, R> - это интерфейс, который принимает параметр типа T и возвращает переменную типа R

Мы используем функцию c .apply()

Function<Integer, Integer> increment = number -> number + 1;
int a = increment.apply(5);
int b = increment.apply(a);
20. Функциональный интерфейс Consumer в Java
Consumer<T> выполняет некоторое действие над объектом типа T, при этом ничего не возвращая:

public interface Consumer<T> {
    void accept(T t);
}
Используем функцию с .accept()

Consumer<String> print = message -> System.out.print(message);
print.accept("Ivan");
21. Функциональный интерфейс Supplier в Java
Supplier<T> не принимает никаких аргументов, но должен возвращать объект типа T:

public interface Supplier<T> {
    T get();
}
Используем функцию с .get()

Supplier<Integer> genRandomInt = () -> new Random().nextInt(51);
int rnd = generateRandomInt.get();
22. Функциональный интерфейс Predicate в Java
Функциональный интерфейс Predicate<T> проверяет соблюдение некоторого условия. Если оно соблюдается, то возвращается значение true.

В качестве параметра лямбда-выражение принимает объект типа T:

public interface Predicate<T> {
    boolean test(T t);
}
Используем функцию с .test()

Predicate<Integer> isEven = number -> number % 2 == 0;
System.out.println(isEven.test(6)); //true
23. Функциональный интерфейс UnaryOperator в Java
UnaryOperator<T> принимает в качестве параметра объект типа T, выполняет над ними операции и возвращает результат операций в виде объекта типа T:

public interface UnaryOperator<T> {
    T apply(T t);
}
Используем функцию с .apply()

UnaryOperator<Integer> square = x -> x * x;
System.out.println(square.apply(5)); // 25
24. BiFunctions
BiFunction <T, U, R> принимает 2 аргумента и возвращает 1 результат

BiFunction <Integer, Integer, String> sum = (x, y) -> "Sum is " + (x + y);
Используем функцию с .apply()

Аналогично:

BiConsumer <T, U>
BiPredicate <T, U>